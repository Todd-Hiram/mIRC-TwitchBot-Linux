on *:text:!uptime*:#: {
  var %uptimetarget $remove($chan,$chr(35))
  set %uptimechannel #
  if ($mysocket(twitchuptime,https://api.twitch.tv/kraken/streams?channel= $+ %uptimetarget)) {
    hadd $v1 channel #
    hadd $v1 stream $1
  }
}
alias twitchuptime {
  if ($2 == error) msg %uptimechannel An error occurred, please try again.
  else {
    if ($bfind(&mysocket,1,"_total":0).text)  { msg %uptimechannel %streamer. [ $+ [ %uptimechannel ] $+ ] .uptime.offline }
    elseif ($bfind(&mysocket,1,created_at).text) { 
      var %uptime $duration($calc($calc($gmt -$ctime($replacex($gettok($bvar(&mysocket,$v1,100).text,3,34),T,$chr(32))))))
      var %uptime.online.now $replace(%streamer. [ $+ [ %uptimechannel ] $+ ] .uptime.now,@uptime@,%uptime) 
      msg %uptimechannel %uptime.online.now 
      unset %uptimechannel
    }
  }
}

alias mysocket {
  if (www.?*.??* iswm $2) tokenize 32 $1 http:// $+ $2
  if (http://?*.??* iswm $2) || (https://?*.??* iswm $2) {
    var %e = $iif($gettok($2,1,47) == https:,-e),%a $gettok($2,2,47),%p $iif($gettok(%a,2,58) isnum 60-65535,$v1,$iif(%e,443,80)),%a $gettok(%a,1,58),%s $sha1($2,0) $+ .mysocket
    mysocket.k %s
    hmake %s
    hadd %s command $1
    hadd %s full $2
    hadd %s port %p
    hadd %s host %a
    hadd %s path $iif($gettok($2,3-,47),/ $+ $v1 $+ $iif($right($2,1) == /,/),/)
    hadd %s limit 2097152
    hadd %s r 0
    sockopen %e %s %a %p
    .timermysocket. $+ %s -io 0 30 mysocket.t %s
    if ($isid) return %s
  }
  else $iif($isid,return,echo -a Invalid input, us as: /mysocket <command> <link>)
}

alias -l mysocket.t if ($sock($1).lr > 30) { $hget($1,command) $1 error open Connection timeout | mysocket.k $1 }

alias -l mysocket.k hfree -w $1 | sockclose $1 | .timermysocket. $+ $1 off | .remove $1 | unset %c.t

on *:sockopen:*.mysocket: {
  tokenize 32 $sockname
  if ($sockerr) mysocket.e $1 open
  else {
    sockwrite -tn $1 GET $hget($1,path) HTTP/1.1
    sockwrite -tn $1 Host: $hget($1,host)
    sockwrite -tn $1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:44.0) Gecko/20100101 Firefox/45.0
    sockwrite -tn $1 Accept: text/html
    sockwrite -tn $1 Connection: close
    sockwrite -t $1 $crlf
  }
}

on *:sockread:*.mysocket: {
  tokenize 32 $sockname
  if ($sockerr) mysocket.e $1 read
  elseif ($hget($1,r)) mysocket.r $1
  else {
    sockread -f %c.t
    while ($sockbr > 2) { hadd $1 %c.t | sockread -f %c.t }
    if ($sockbr) { hadd $1 r $calc($sock($1).rcvd +$iif($hget($1,Content-Length:) <= $hget($1,limit),$v1,$v2)) | if ($sock($1).rq) mysocket.r $1 }
  }
}

on *:sockclose:*.mysocket:mysocket.d $sockname

alias -l mysocket.r sockread $sock($1).rq &b | bwrite $1 -1 &b | if ($sock($1).rcvd >= $hget($1,r)) mysocket.d $1

alias -l mysocket.e $hget($1,command) $1 error $2 $sockerr $sock($1).wsmsg | mysocket.k $1

alias -l mysocket.d {
  if ($hget($1,Transfer-Encoding:) == chunked) {
    var %y = 1
    bread $1 0 $file($1).size &f
    while ($bfind(&f,%y,$crlf).text) {
      var %v = $v1,%h $bvar(&f,%y,$calc(%v -%y)).text,%r $base(%h,16,10),%y $calc(%v +4+%r)
      if (%r == 0) break
      else bcopy &mysocket $calc(1+$bvar(&mysocket,0)) &f $calc(2+%v) %r
    }
  }
  else bread $1 0 $file($1).size &mysocket
  if ($hget($1,HTTP/1.1) != 200 OK) $hget($1,command) $1 error status $v1
  else $hget($1,command) $1 $iif($bvar(&mysocket,0),done,error read No data received.)
  mysocket.k $1
  :error
  if ($error) mysocket.k $1
